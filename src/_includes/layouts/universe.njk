{% extends "base.njk" %}


  {% block content %}



    <div id="info-box" class="info-box"></div>

    <div  class="year-label"><span id="year-label" ></span>
     <button id="pause_resume">Pause</button> </div>
    <div class="title-box">
        <h1>Europe Household Exploration</h1>
        <h2>Over on a country to explore its household data, you can zoom, rotate, and filter</h2>
        Data sources: <a href="https://ec.europa.eu/eurostat/web/main/data/database">Eurostat</a>
    </div>
    <div id="legend" class="legend"></div>
    <div id="filter-box" class="filter-box">
        <label for="size-field">Select size field:</label>
        <select id="size-field">
            <option value="population">Population</option>
            <option value="house_disp" selected="selected" >Household Disp</option>
            <option value="not_employ_total">Unemployment total</option>
            <option value="employ_f">Female employ</option>
            <option value="employ_m">Male employ</option>
        </select>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/DragControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/23.1.2/tween.umd.min.js"></script>

    <script src="{{ site.assets }}/country-data.js"></script>
    <script>
        // Data

        // Colors for categories
        const colors = {
            'HHC_21': 0x4b5320, // Verde militar
            'HHC_22': 0x6b8e23, // Verde más claro
            'HHC_31': 0xadd8e6, // Azul claro
            'HHC_32': 0x0000ff, // Azul
            'HHC_41': 0x00008b, // Azul oscuro
            'HHC_42': 0x800080  // Morado
        };

        // Initialize scene, camera, and renderer
        var countryCoordinatesNew = countryCoordinates ;
        const scene = new THREE.Scene();
        const axesHelper = new THREE.AxesHelper( 500);
        const backgroundGeometry = new THREE.PlaneGeometry(20000, 20000);
        const backgroundMaterial = new THREE.ShaderMaterial({
            uniforms: {
                color1: { value: new THREE.Color(0xffffff) }, // Color blanco
                color2: { value: new THREE.Color(0x0000ff) }  // Color azul
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 color1;
                uniform vec3 color2;
                varying vec2 vUv;
                void main() {
                    gl_FragColor = vec4(mix(color1, color2, vUv.y), 1.0);
                }
            `,
            side: THREE.DoubleSide
        });

        const background = new THREE.Mesh(backgroundGeometry, backgroundMaterial);
        background.position.set(0, 0, -1000); // Asegúrate de que esté detrás de todo
        scene.add(background);

        // Add legend items
        const legendContainer = document.getElementById('legend');
        Object.keys(colors).forEach(key => {
            const color = colors[key];
            const hexColor = '#' + color.toString(16).padStart(6, '0'); 

            const item = document.createElement('div');
            item.className = 'item';
            item.innerHTML = `<span class="color-box" style="background-color: ${hexColor};"></span>${hhcDescriptions[key]}`;
            legendContainer.appendChild(item);
        });

        scene.add( axesHelper );
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        const scale=5.7;
        const centerX = 0;
        const centerY = 0;
        const centerZ = 0;  

        // Cargar la textura del mapa de Europa
        const mapTexture = loader.load('{{ site.assets }}/europe.svg');
        const floorWidth = 1000;
        const floorHeight = 684;
        const floorCenterX =   floorWidth / 2;
        const floorCenterY =   floorHeight / 2;
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            map: mapTexture, 
            side: THREE.DoubleSide, 
            transparent: true, 
            opacity: 0.2 
        });
        const floorGeometry = new THREE.PlaneGeometry(floorWidth/2, floorHeight/2);
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);

        floor.rotation.z = 0; // Asegurarse de que el plano esté en el plano XY
        floor.transparency = true; 
        floor.material.opacity = 0.2;
        floor.position.set(0, floorHeight / 4, 0); // Posicionar el plano en el centro del mapa
        scene.add(floor);


        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // OrbitControls for camera
        const controls = new THREE.OrbitControls(camera, renderer.domElement);

         // Restricción del ángulo de rotación horizontal (azimutal)
        controls.minAzimuthAngle = - Math.PI / 24; // Ajustar según el valor actual de la cámara
        controls.maxAzimuthAngle =  Math.PI / 24; // Ajustar según el valor actual de la cámara

        // Restricción del ángulo de rotación vertical (polar) para mantener la cámara en el plano XY
        controls.minPolarAngle =  Math.PI - Math.PI/3; // Permitir un pequeño rango alrededor del valor actual
        controls.maxPolarAngle =  Math.PI - Math.PI/4; // Permitir un pequeño rango alrededor del valor actual  

        // Configurar OrbitControls para mantener la cámara en el plano XY
        controls.enableRotate = true;
        controls.enableZoom = true;
        controls.enablePan = true;
        controls.minDistance = 50;
        controls.maxDistance = 500;
        
        // Ajustar la posición de la cámara
        const distance = 300;
        const angle = THREE.Math.degToRad(60);
        const cameraPos = new THREE.Vector3(24, -17, 200);
        const cameraCenterX = centerX * Math.sin(angle)
        const cameraCenterY = centerY
        camera.position.set(cameraCenterX, cameraCenterY, 350);
        controls.target.set(0, 100, 0);


        // Create spheres for each country and its categories
        const countries = {};
        const categorySpheres = [];
        const data = [
          {% for item in universe.data %}
            {year: {{ item.year }}, geo: '{{ item.geo }}', hh: '{{ item.hh }}', house_disp: {{ item.house_disp }}, not_employ_total: {{ item.not_employ_total }}, population: {{ item.population }}, employ_f: {{ item.employ_f }}, employ_m: {{ item.employ_m }}},
          {% endfor %}
        ];
        function createCountrySphere(geo) {
            const countryGeometry = new THREE.BoxGeometry(10, 10, 10);
            const countryMaterial = new THREE.MeshStandardMaterial({
                map: flagTextures[geo],
                emissive: 0x333333,
                emissiveIntensity: 0.1
            });
            const countrySphere = new THREE.Mesh(countryGeometry, countryMaterial);
            countrySphere.userData = { geo };
            return countrySphere;
        }

        function createCategorySphere(hh, color, size) {
            const categoryGeometry = new THREE.SphereGeometry(size, 64, 64);
            const categoryMaterial = new THREE.MeshStandardMaterial({ color });
            const categorySphere = new THREE.Mesh(categoryGeometry, categoryMaterial);
            return categorySphere;
        }

        function initializeDataForYear(year) {
            var filter = document.getElementById('size-field').value;
            const values = data.filter(item => item.year === year).map(item => item[filter]);
            const minSize = Math.min(...values);
            const maxSize = Math.max(...values);
            const scale_data = (maxSize - minSize) === 0 ? 1 : 10 / (maxSize - minSize);

            data.forEach(item => {
                if (item.year === year) {
                    if (!countries[item.geo]) {
                        const countrySphere = createCountrySphere(item.geo);
                        const { x, y } = countryCoordinates[item.geo];
                        countrySphere.id = item.geo;
                        //countrySphere.position.set( x * scale - 45,   y * scale - 160, 1); // Ajustar posición Z para estar justo encima del mapa
                        countrySphere.position.set( x, y, 1); // Ajustar posición Z para estar justo encima del mapa
                        countries[item.geo] = countrySphere;
                        countrySphere.userData = {
                            geo: item.geo,
                            isCountry: true
                        }
                        scene.add(countrySphere);
                    }

                    //obtenemos el filtro activo
                    
                    //var size = item[filter]/10;
                    let size = (item[filter] - minSize) * scale_data + 1;
                    size = Math.max(size, 1);
                   

                    //size = size * scale_data;
                    //console.log("data", size, filter, item.hh, colors[item.hh]);
                    const categorySphere = createCategorySphere(item.hh, colors[item.hh], size);
                    categorySphere.userData = {
                        country: countries[item.geo],
                        isCountry: false,
                        geo: item.geo,
                        distance:   10,
                        angle: Math.random() * Math.PI*2,
                        speed:  0.01,
                        population: item.population,
                        not_employ_total: item.not_employ_total,
                        house_disp: item.house_disp,
                        employ_f: item.employ_f,
                        employ_m: item.employ_m,
                        hh: item.hh
                    };
                    
                    categorySpheres.push(categorySphere);
                    scene.add(categorySphere);
                }
            });
        }

        // Initialize data for the initial year
        let currentYear = 2022;
        initializeDataForYear(currentYear);

        // Add a light source
        const ambientLight = new THREE.AmbientLight(0xededed, 0.5);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xededff, 0.7);
        camera.add(pointLight);
        scene.add(camera);

        // DragControls for moving spheres
        const draggableObjects = Object.values(countries).concat(categorySpheres);
        const dragControls = new THREE.DragControls(draggableObjects, camera, renderer.domElement);
        dragControls.addEventListener('dragstart', function (event) {
            controls.enabled = false;
        });
        dragControls.addEventListener('dragend', function (event) {
            controls.enabled = true;

        });

        // Restringir movimiento en eje Z
        dragControls.addEventListener('drag', function (event) {
            event.object.position.z = 1;  // Bloquear movimiento en Z
        });

        dragControls.addEventListener('drag', function (event) {
            event.object.position.z = 1;  // Mantener posición Z en 1
        });

        // Raycaster for detecting mouseover
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const infoBox = document.getElementById('info-box');

        function onMouseMove(event) {
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects(draggableObjects);

            if (intersects.length > 0) {
                const intersected = intersects[0].object;
                const { geo, house_disp, hh, not_employ_total, employ_m, employ_f, population } = intersected.userData;
                infoBox.style.display = 'block';
                infoBox.style.left = `${event.clientX + 10}px`;
                infoBox.style.top = `${event.clientY + 10}px`;
                if(house_disp){
                    infoBox.innerHTML = `<b>${countryNames[geo]}<br>${hhcDescriptions[hh]}</b> <br> Income Disp: ${house_disp.toFixed(2)} <br> Unemploy: ${not_employ_total.toFixed(2)}<br> Employ Male: ${employ_m.toFixed(2)}<br>Employ Female: ${employ_f.toFixed(2)} <br> Population: ${population.toFixed(2)}`;
                } else {
                    infoBox.innerHTML = `${countryNames[geo]}`;
                }
                // Hacer semitransparentes todas las esferas excepto la intersectada
                draggableObjects.forEach(sphere => {
                    if (sphere == intersected) {
                        activeGeo = sphere.userData.geo;
                        pause = false;
                        resume_play();
                    }
                });
                console.log('activeGeo', activeGeo);
                draggableObjects.forEach(sphere => {
                    
                    if (sphere.userData.geo !== activeGeo) {
                        sphere.material.opacity = 0.2;
                        sphere.material.transparent = true;
                        sphere.userData.animationPaused = false; // Marcar como pausada
                    } else {
                        sphere.material.opacity = 1.0;
                        sphere.userData.animationPaused = true; // Marcar como no pausada
                    }
                });
            } else {
                activeGeo = null;
                infoBox.style.display = 'none';
                draggableObjects.forEach(sphere => {
                            sphere.material.opacity = 1.0;
                            sphere.userData.animationPaused = false; // Marcar como no pausada
                        });
            }
        }

        window.addEventListener('mousemove', onMouseMove, false);

        function onMouseClick(event) {
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects(Object.values(countries));

            if (intersects.length > 0) {
                const intersected = intersects[0].object;
                const { x, y } = intersected.position;

                // Move the camera to the new position
                const targetPosition = new THREE.Vector3(x, y, 0);
                const newCameraPosition = new THREE.Vector3(
                    x + distance * Math.sin(angle),
                    y + distance * Math.cos(angle),
                    distance
                );

                // Smooth camera transition
                new TWEEN.Tween(camera.position)
                    .to(newCameraPosition, 2000)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();

                // Update controls target
                //controls.target.set(targetPosition.x, targetPosition.y, targetPosition.z);
                draggableObjects.forEach(object => {
                    const geo = object.userData.geo;
                    if (geo) {
                        var xNew = object.position.x;
                        var yNew = object.position.y;
                        countryCoordinatesNew[geo] = { x: xNew, y: yNew };
                    }
                });
                //console.log('var countryCoordinates =', JSON.stringify(countryCoordinatesNew, null, 2));

            }
        }
        window.addEventListener('click', onMouseClick, false);

        // play pause
        var pause = false;
        var animationDelay = 4000;
        document.getElementById('pause_resume').addEventListener('click', (event) => {
           resume_play();
        });

        function resume_play(){
            if (pause) {
                pause = false;
                document.getElementById('pause_resume').innerHTML = 'Pause';
                timerAnimation = setTimeout(updateYearData, animationDelay);
            } else {
                pause = true;
                document.getElementById('pause_resume').innerHTML = 'Resume';
                clearTimeout(timerAnimation);
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Update positions of category spheres
            categorySpheres.forEach(sphere => {
                if (sphere.userData.animationPaused) {
                    return;
                }
                sphere.userData.angle += sphere.userData.speed;
                const distance = sphere.userData.distance;
                sphere.position.x = sphere.userData.country.position.x + distance * Math.cos(sphere.userData.angle);
                sphere.position.y = sphere.userData.country.position.y + distance * Math.sin(sphere.userData.angle);
                sphere.position.z = sphere.userData.country.position.z //+ distance * Math.sin(sphere.userData.angle);
            });

            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Update year and data every 5 seconds
        const yearLabel = document.getElementById('year-label');

        function updateYearData() {
            // Clear previous spheres
            categorySpheres.forEach(sphere => scene.remove(sphere));
            categorySpheres.length = 0;

            currentYear++;
            if (currentYear > 2022) {
                currentYear = 2007;
            }

            initializeDataForYear(currentYear);
            yearLabel.innerHTML = `Year: ${currentYear}`;
            if(!pause)
                timerAnimation = setTimeout(updateYearData, animationDelay);
        }

        yearLabel.innerHTML = `Year: ${currentYear}`;
        timerAnimation = setTimeout(updateYearData, animationDelay);

        // Variable para el campo seleccionado
        let selectedField = 'house_disp';

        // Evento para cambiar el campo seleccionado
        document.getElementById('size-field').addEventListener('change', (event) => {
            selectedField = event.target.value;
            updateSpheresSize();
        });

        function updateSpheresSize() {
            categorySpheres.forEach(sphere => {
                const size = sphere.userData[selectedField]; // Ajustar el factor de escala según sea necesario
                console.log(size);
                sphere.geometry = new THREE.SphereGeometry(size/10, 64, 64);
            });
        }


    </script>
  {% endblock %}